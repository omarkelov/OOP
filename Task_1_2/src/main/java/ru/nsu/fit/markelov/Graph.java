package ru.nsu.fit.markelov;

public class Graph {

    private int[][] mWeights;
    private boolean mDirected;

   /**
    * Creates an empty undirected Graph (with no weights of edges defined).
    * <p>
    * The implementation requires O (n^2) memory for n nodes.
    * <p>
    * An IllegalArgumentException is thrown if nodesCount parameter less
    * than one is passed.
    *
    * @param nodesCount a number of nodes in a graph
    * @see   IllegalArgumentException
    */
    public Graph(int nodesCount) {
        this(nodesCount, false);
    }

   /**
    * Creates an empty directed or undirected Graph (with no weights of edges defined).
    * <p>
    * The implementation requires O (n^2) memory for n nodes.
    * <p>
    * An IllegalArgumentException is thrown if nodesCount parameter less
    * than one is passed.
    *
    * @param nodesCount a number of nodes in a graph
    * @param directed   a flag to define whether a Graph is directed
    * @see   IllegalArgumentException
    */
    public Graph(int nodesCount, boolean directed) {
        if (nodesCount < 1) {
            throw new IllegalArgumentException("Invalid nodes amount.");
        }

        mWeights = new int[nodesCount+1][nodesCount+1];
        mDirected = directed;
    }

   /**
    * Creates an undirected Graph using an adjacency matrix to define weights of edges.
    * <p>
    * The implementation requires O (n^2) memory for n nodes.
    *
    * @param weights an adjacency matrix of weights of edges
    */
    public Graph(int[][] weights) {
        this(weights, false);
    }

   /**
    * Creates a Graph using an adjacency matrix to define weights of edges.
    * <p>
    * The implementation requires O (n^2) memory for n nodes.
    *
    * @param weights  an adjacency matrix of weights of edges
    * @param directed a flag to define whether a Graph is directed
    */
    public Graph(int[][] weights, boolean directed) {
        mWeights = new int[weights.length+1][weights.length+1];
        for (int i = 1; i < mWeights.length; i++) {
            for (int j = 1; j < mWeights.length; j++) {
                mWeights[i][j] = weights[i-1][j-1];
            }
        }

        mDirected = directed;
    }

   /**
    * Adds an edge to a Graph.
    * <p>
    * If Graph is undirected, reversed edge is also added.
    * <p>
    * An IllegalArgumentException is thrown if there is no such
    * node in the graph.
    *
    * @param fromNode source node of edge
    * @param toNode   sink node of edge
    * @param weight   a weight of edge
    */
    public void addEdge(int fromNode, int toNode, int weight) {
        verifyNode(fromNode);
        verifyNode(toNode);
        // ?????????????????????????????????????????????????????????????????????????????????????????????????????????
        // ?????????????????????????????????????????????????????????????????????????????????????????????????????????
        // ??????????????????????????????????? Выполнится ли в случае исключения ???????????????????????????????????
        // ?????????????????????????????????????????????????????????????????????????????????????????????????????????
        // ?????????????????????????????????????????????????????????????????????????????????????????????????????????
        mWeights[fromNode][toNode] = weight;
        if (!mDirected) {
            mWeights[toNode][fromNode] = weight;
        }
    }

    private void verifyNode(int node) {
        if (node < 1 || node > mWeights.length) {
            throw new IllegalArgumentException("'" + node + "' is invalid value for node parameters");
        }
    }

    /*public void printGraph() {
        for (int i = 1; i < mWeights.length; i++) {
            for (int j = 1; j < mWeights.length; j++) {
                System.out.print(mWeights[i][j] + " ");
            }
            System.out.println();
        }
    }*/

    // ----- Setters & Getters -----

    /**
     * @return the adjacency matrix of the graph
     */
    public int[][] getWeights() {
        return mWeights;
    }
}
